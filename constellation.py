
#*****************************************************************************
#       Copyright (C) 2013 Bruce Westbury Bruce.Westbury@warwick.ac.uk
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************

""" This is an implementation of genus zero hypermaps.

A hypermap can be defined as any of the following:
 * Three permutations (of the same size) whose composite is the identity.
 * A bipartite graph embedded in a oriented surface and such that any connected
 component of the complement is homeomorphic to the open disc.
 * A set with three fixed point free involutions.

There is the notion of disjoint union in each case which gives the
definition of connected components. We assume we are connected.

The genus is the genus of the oriented surface.

A genus zero hypermap is also equivalent to a rational function whose
branch points are a subset of $(0,1,\infty)$. The rational functon is
uniquely determined up to a Mobius transformation of the variable.

The monodromy group is the subgroup of the permutation group generated by
the three permutations.

The bipartite graph is a tree if and only if the third permutation is conjugate
to the long cycle. Equivalently the cyclic group generated by this permutation
acts transitively. In this case the rational function can be taken to be a
polynomial. This polynomial is uniquely determined up to a linear change of variable.

A Shabat polynomial is a polynomial with (at most) two critical values.
For example, $z^n$ is a Shabat polynimial with one critical value.
The derivative is $nz^{n-1}$; the solutions are $z=0$, and evaluating at these
values always gives $0$. The only monic polynomials with one critical value
are the polynomials $(z-a)^n$. The only critical value is $0$.

The Chebychev polynomials $1,z,z^2-1,z^3-2z,...$ are also Shabat polynomials.

The following paper shows that using circle packing we can approximate the Belyi function.
There is a sequence of circle packings given by hexagonal subdivision of each triangle.

Philip L. Bowers and Kenneth Stephenson
Uniformizing dessins and Belyi maps via circle packing
Mem. Amer. Math. Soc. 170 (2004)
MR2053391

"""

import closedgraph
import ribbon
import spider
from surface import SurfaceComplex

from collections import namedtuple

Circle = namedtuple('Circle',['type','points'])

from math import pi, sin, cos, acos
from cmath import rect

def get_orbits(perm):
    """Finds the orbits of a permutation.

    INPUT: A list (representing a permutation of 0,1,...,(N-1)

    OUTPUT: A list of lists giving a set partition of 0,1,...,(N-1)

    EXAMPLES:

    >>> get_orbits([1,0,3,2])
    ((0, 1), (2, 3))

    """
    N = len(perm)
    S = set(range(N))

    orbits = []
    while S != set():
        s = S.pop()
        v = [s]
        while perm[s] in S:
            t = perm[s]
            v.append(t)
            S.remove(t)
            s = t
        orbits.append(tuple(v))

    return tuple(orbits)

class HyperMap(object):
    """ The class of configurations."""

    error = 0.00001

    def __init__(self,sigma,alpha,phi,inv=None):
        """
        INPUT: Three lists. Each list is a permutation of 0,1,...,N-1.
        The composite of the three permutations is the identity.

        These examples are first terms in a sequence of examples.
        In these examples the bipartite graph is an interval.
        The associated polynomials are the Chebychev polynomials.

        EXAMPLES:

        >>> HyperMap([0],[0],[0])
        sigma: [0]
        alpha: [0]
        phi:   [0]

        >>> HyperMap([0,1],[1,0],[1,0])
        sigma: [0, 1]
        alpha: [1, 0]
        phi:   [1, 0]

        >>> HyperMap([0,2,1],[1,0,2],[2,0,1])
        sigma: [0, 2, 1]
        alpha: [1, 0, 2]
        phi:   [2, 0, 1]

        >>> HyperMap([0,2,1,3],[1,0,3,2],[2,0,3,1])
        sigma: [0, 2, 1, 3]
        alpha: [1, 0, 3, 2]
        phi:   [2, 0, 3, 1]

        >>> HyperMap([0,2,1,4,3],[1,0,3,2,4],[2,0,4,1,3])
        sigma: [0, 2, 1, 4, 3]
        alpha: [1, 0, 3, 2, 4]
        phi:   [2, 0, 4, 1, 3]

        >>> HyperMap([0,2,1,4,3,5],[1,0,3,2,5,4],[2,0,4,1,5,3])
        sigma: [0, 2, 1, 4, 3, 5]
        alpha: [1, 0, 3, 2, 5, 4]
        phi:   [2, 0, 4, 1, 5, 3]

        >>> HyperMap([0,2,1,4,3,6,5],[1,0,3,2,5,4,6],[2,0,4,1,6,3,5])
        sigma: [0, 2, 1, 4, 3, 6, 5]
        alpha: [1, 0, 3, 2, 5, 4, 6]
        phi:   [2, 0, 4, 1, 6, 3, 5]

        """
        N = len(sigma)
        if N < 1:
            raise ValueError
        if len(phi) != N or len(alpha) != N:
            raise ValueError
        S = { i for i in range(N) }
        if set(sigma) != S or set(phi) != S or set(alpha) != S:
            raise ValueError
        if any( phi[alpha[sigma[i]]] != i for i in range(N) ):
            raise ValueError

        self.degree = N
        self.sigma = sigma
        self.phi = phi
        self.alpha = alpha

        self.involution = inv

    def __repr__(self):
        return 'sigma: %s\nalpha: %s\nphi:   %s' \
               % (self.sigma, self.alpha, self.phi)

    @property
    def black_vertices(self):
        """Returns the orbits of sigma."""
        return get_orbits(self.sigma)

    @property
    def white_vertices(self):
        """Returns the orbits of alpha."""
        return get_orbits(self.alpha)

    @property
    def faces(self):
        """Returns the orbits of phi."""
        return get_orbits(self.phi)

    @property
    def genus(self):
        """Calculates the genus of a hypermap.

        EXAMPLES:

        >>> interval(4).genus
        0

        """

        chi = len(self.black_vertices) + len(self.white_vertices) + len(self.faces) - self.degree
        if chi % 2 != 0:
            raise RuntimError
        return 1 - chi/2

    @property
    def passport(self):
        """Calculates the passport of a hypermap.
        This is a list of three partitions of the degree of the hypermap.

        EXAMPLES:

        >>> interval(4).passport
        [[2, 1], [0, 2], [0, 0, 0, 1]]

        """
        ars = [ len(v) for v in self.black_vertices ]
        bs = [ ars.count(i+1) for i in range( max(ars) ) ]
        aa = [ len(v) for v in self.white_vertices ]
        ba = [ aa.count(i+1) for i in range( max(aa) ) ]
        ap = [ len(v) for v in self.faces ]
        bp = [ ap.count(i+1) for i in range( max(ap) ) ]
        return [bs,ba,bp]

    @property
    def is_connected(self):
        """Determines if the hypermap is connected.

        EXAMPLES:

        >>> interval(4).is_connected
        True

        """
        orbit = {0}
        done = False
        while not done:
            done = True
            new = { self.sigma[i] for i in orbit if self.sigma[i] not in orbit }
            if len(new) != 0:
                done = False
                orbit = orbit.union(new)
            new = { self.alpha[i] for i in orbit if self.alpha[i] not in orbit }
            if len(new) != 0:
                done = False
                orbit = orbit.union(new)
            new = { self.phi[i] for i in orbit if self.phi[i] not in orbit }
            if len(new) != 0:
                done = False
                orbit = orbit.union(new)

        return len(orbit) == self.degree

    def get_circles(self):
        self.Bcircles = [ Circle('BV',frozenset(x)) for x in self.black_vertices ]
        self.Wcircles = [ Circle('WV',frozenset(x)) for x in self.white_vertices ]
        self.Fcircles = [ Circle('FC',frozenset(x)) for x in self.faces ]

    def get_triangles(self):
        if not all([hasattr(self,'Bcircles'),hasattr(self,'Wcircles'),hasattr(self,'Fcircles')]):
            self.get_circles()

        DB = dict()
        for x in self.Bcircles:
            for a in x.points:
                DB[a] = x

        DW = dict()
        for x in self.Wcircles:
            for a in x.points:
                DW[a] = x

        DF = dict()
        for x in self.Fcircles:
            for a in x.points:
                DF[a] = x

        r = range(self.degree)
        self.triangles = [(DB[a],DW[a],DF[a],True,) for a in r]\
                   + [(DB[self.alpha[a]],DW[self.alpha[a]],DF[a],False,) for a in r]

    def map(self):
        labels = ('VE','VF','EV','EF','FV','FE',)
        flags = dict([])
        for l in labels:
            for i in range(self.degree):
                flags[(i,l,)] = ribbon.halfedge()

        for i in range(self.degree):
            flags[(i,'VE',)].e = flags[(i,'EV',)]
            flags[(i,'EV',)].e = flags[(i,'VE',)]
            flags[(i,'VF',)].e = flags[(i,'FV',)]
            flags[(i,'FV',)].e = flags[(i,'VF',)]
            flags[(i,'FE',)].e = flags[(i,'EF',)]
            flags[(i,'EF',)].e = flags[(i,'FE',)]

            #flags[(i,'VE',)]).c = flags[(self.sigma[i],'VF',)]
            flags[(self.sigma[i],'VE',)].c = flags[(i,'VF',)]
            flags[(i,'EV',)].c = flags[(i,'EF',)]
            flags[(i,'VF',)].c = flags[(i,'VE',)]
            flags[(self.phi[i],'FV',)].c = flags[(i,'FE',)]
            flags[(i,'FE',)].c = flags[(i,'FV',)]
            #flags[(i,'EF',)].c = flags[(self.alpha[i],'EV',)]
            flags[(self.alpha[i],'EF',)].c = flags[(i,'EV',)]

        for i in range(self.degree):
            flags[(i,'EV',)].decorations = ribbon.Features('neither','red',True)
            flags[(i,'VE',)].decorations = ribbon.Features('neither','red',True)
            flags[(i,'FV',)].decorations = ribbon.Features('neither','blue',True)
            flags[(i,'VF',)].decorations = ribbon.Features('neither','blue',True)
            flags[(i,'FE',)].decorations = ribbon.Features('neither','green',True)
            flags[(i,'EF',)].decorations = ribbon.Features('neither','green',True)
            
        g = ribbon.justgraph(set(flags.values()))

        a = self.faces[0]
        x = flags[(a[0],'FE',)]
        out = [x]
        y = x.c
        while y != x:
            out.append(y)
            y = y.c
        out.reverse()

        sut = [ flags[(i,'FE',)] for i in a ] + [ flags[(i,'FV',)] for i in a ]
        if set(sut) != set(out):
            raise RuntimeError

        return g, out

    def ribbon(self):
        g1, out1 = self.map()
        #g1.inspect()
        g2, inc1 = g1.subdivision()
        #g2.inspect()
        out2 = [ inc1[x] for x in out1 ]
        g3, inc2 = g2.subdivision()
        out3 = [ inc2[x] for x in out2 ]
        #g3.inspect()

        #g, out = g3, out3
        g, out = g2, out2

        bd = [ x.e for x in out ]
        he = g.he
        for x in out:
            x.e.e = None
            he.remove(x)

        gj = ribbon.justgraph(he)

        return spider.RibbonGraph(gj,bd)

    def report(self):
        SurfaceComplex(self.ribbon().closure()).report()
        
    def show(self,style,name=None):
        """
        EXAMPLES:

         interval(4).show('SVG')

         star(5).show('SVG')

         HyperMap([0,2,1],[1,0,2],[2,0,1]).show('SVG')

         HyperMap([0,2,1,3],[1,0,3,2],[2,0,3,1]).show('SVG')

         HyperMap([0,2,1,4,3],[1,0,3,2,4],[2,0,4,1,3]).show('SVG')

         HyperMap([0,2,1,4,3,5],[1,0,3,2,5,4],[2,0,4,1,5,3]).show('SVG')

         HyperMap([0,2,1,4,3,6,5],[1,0,3,2,5,4,6],[2,0,4,1,6,3,5]).show('SVG')

        """

        g = self.ribbon()
        g.show(
            geometry = 'hyperbolic',
            boundary = 'Dirichlet',
            style = style,
            name = name)

    def layout(self):
        """This makes the following assumptions:
         * The hypermap is connected
         * The hypermap has genus zero
         * The permutation phi is a complete cycle
        """
        print "Using constellation.layout()."
        
        self.get_triangles()

        circles = self.Bcircles + self.Wcircles + self.Fcircles
        radius = dict( (c,1) for c in circles )

        # Dictionary for number of neighbours
        nb = dict( (c,len([ t for t in self.triangles if c in t ])) for c in circles )

        # Dictionary for number used for correction.
        fc = dict( ( c, 1-1/sin(pi/nb[c]) ) for c in circles )

        angle = {}

        packing = False
        count = 0
        while not packing:
            packing = True
            count += 1
            for c in circles:
                angle[c] = 0.0

            for t in self.triangles:
                u = [ radius[t[i]] for i in range(3) ]
                a = [ u[i-2]+u[i-1] for i in range(3) ]
                # see Stephenson p. 57 for spherical formulae
                for i in range(3):
                    num = cos(a[i])-cos(a[i-1])*cos(a[i-2])
                    den = sin(a[i-1])*sin(a[i-2])
                    angle[t[i]] += acos( num/den )

            for c in circles:
                s = sin( angle[c]/(2*nb[c]) )
                r = radius[c] * fc[c] * s / (s-1)
                if abs(r-radius[c]) > HyperMap.error:
                    packing = False
                radius[c] = r

        self.radius = radius

def star(n):
    """Constructs the hypermap corresponding to the star with n points."""
    if not n>0:
        raise ValueError
    sigma = [0] * n
    alpha = [0] * n
    phi = [0] * n
    for i in range(n):
        sigma[i] = i
        alpha[i-1] = i
        phi[i-n+1] = i
    return HyperMap(sigma,alpha,phi)


def interval(n):
    """Constructs the hypermap corresponding to the interval with n points."""
    if not n>0:
        raise ValueError
    sigma = [0] * n
    alpha = [0] * n
    phi = [0] * n
    if n % 2 == 0:
        for i in range(2,n,2):
            sigma[i] = i-1
            sigma[i-1] = i
        sigma[n-1] = n-1
        for i in range(0,n,2):
            alpha[i] = i+1
            alpha[i+1] = i
    else:
        for i in range(1,n,2):
            sigma[i] = i+1
            sigma[i+1] = i
            alpha[i] = i-1
            alpha[i-1] = i
        alpha[n-1] = n-1
    v = [ alpha[sigma[i]] for i in range(n) ]
    for i in range(n):
        phi[v[i]] = i
    return HyperMap(sigma,alpha,phi)


# This is to run the tests in the examples.
# http://docs.python.org/library/doctest.html
if __name__ == "__main__":
    import doctest
    doctest.testmod()


